<!-- http://www.html5canvastutorials.com/labs/html5-canvas-graphing-an-equation/ -->
<!DOCTYPE HTML>
<html lang="fr">
<!-- HEAD START -->
<head>
    <meta charset="UTF-8">
    <title>Labo 2 | Equipe 4</title>
    <!-- CSS START -->
    <style>
        body { margin: 5px; padding: 0px; font-family: 'Calibri', sans-serif;}
        #myCanvas { background-color: #ecf0f1; }
    </style>
    <!-- CSS END -->
</head>
<!-- HEAD END -->
<!-- BODY START -->
<body>
<h2>Résolution d'équations</h2>
<p><label for="equ1"><input type="radio" name="equation" id="equ1"/>sin(x)-x/13</label></p>
<p><label for="equ2"><input type="radio" name="equation" id="equ2"/>x/(1-x<sup>2</sup>)</label></p>
<p><label for="lambda">Lambda (&lambda;) <input type="number" name="lambda" id="lambda" value="1"/></label></p>
<h3>Graphique</h3>
<p id="racines"></p>
<!-- set canvas -->
<canvas id="myCanvas" width="600px" height="600px">
    Votre navigateur ne supporte pas les canevas (HTML5)
</canvas>
<p>
    <span style="color: red;">f(x)</span> //
    <span style="color: green;">y = x</span> //
    <span style="color: blue;">g(x) = x + &lambda; f(x)</span>
</p>
<!-- JAVASCRIPT START -->
<script>
    var Fx = [];
    var Gx = [];
    var Dx = [];
    var racines = [];
    var equationSelected;

    function Graph(config) {
        // USER DEFINED PROPERTIES
        this.canvas = document.getElementById(config.canvasId);
        // minima X + Y
        this.minX = config.minX;
        this.minY = config.minY;
        // maxima X + Y
        this.maxX = config.maxX;
        this.maxY = config.maxY;
        // units
        this.unitsPerTick = config.unitsPerTick;

        // CONSTANTS
        this.axisColor = '#aaa';
        this.font = '8pt Calibri';
        this.tickSize = 10;

        // RELATIONSHIP
        this.context = this.canvas.getContext('2d');
        // set range X + Y
        this.rangeX = this.maxX - this.minX;
        this.rangeY = this.maxY - this.minY;
        // set units on graph X + Y
        this.unitX = this.canvas.width / this.rangeX;
        this.unitY = this.canvas.height / this.rangeY;
        // set center X + Y
        this.centerY = Math.round(Math.abs(this.minY / this.rangeY) * this.canvas.height);
        this.centerX = Math.round(Math.abs(this.minX / this.rangeX) * this.canvas.width);
        // set iteration X
        this.iteration = (this.maxX - this.minX) / 1000;
        // set scale X + Y
        this.scaleX = this.canvas.width / this.rangeX;
        this.scaleY = this.canvas.height / this.rangeY;

        // clear old graph
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

        //DRAW AXIS X + Y : defined below
        this.drawXAxis();
        this.drawYAxis();
    }
    /**
     * FUNCTION : DRAW X-AXIS
     */
    Graph.prototype.drawXAxis = function() {
        // RETRIEVE CONTEXT
        var context = this.context;
        // context settings
        context.save();
        context.beginPath();
        // move to Y-center : draw X-axis
        context.moveTo(0, this.centerY);
        context.lineTo(this.canvas.width, this.centerY);
        // set style
        context.strokeStyle = this.axisColor;
        context.lineWidth = 1;
        context.stroke();

        // DRAW TICK MARKS
        var xPosIncrement = this.unitsPerTick * this.unitX;
        var xPos, unit;
        // text settings
        context.font = this.font;
        context.textAlign = 'center';
        context.textBaseline = 'top';

        // DRAW LEFT TICK MARKS
        xPos = this.centerX - xPosIncrement;
        unit = -1 * this.unitsPerTick;
        //while X-position greater than 0
        while(xPos > 0){
            // draw ticks + unit
            context.moveTo(xPos, this.centerY - this.tickSize / 2);
            context.lineTo(xPos, this.centerY + this.tickSize / 2);
            context.stroke();
            context.fillText(unit, xPos, this.centerY + this.tickSize / 2 + 3);
            // change X-position + unit value
            unit -= this.unitsPerTick;
            xPos = Math.round(xPos - xPosIncrement);
        }

        // DRAW RIGHT TICK MARKS
        xPos = this.centerX + xPosIncrement;
        unit = this.unitsPerTick;
        // while X-position smaller than canvas width
        while(xPos < this.canvas.width){
            // draw ticks + unit
            context.moveTo(xPos, this.centerY - this.tickSize / 2);
            context.lineTo(xPos, this.centerY + this.tickSize / 2);
            context.stroke();
            context.fillText(unit, xPos, this.centerY + this.tickSize / 2 + 3);
            // change X-position + unit value
            unit += this.unitsPerTick;
            xPos = Math.round(xPos + xPosIncrement);
        }
        context.restore();
    };
    /**
     * FUNCTION : DRAW Y-AXIS
     */
    Graph.prototype.drawYAxis = function(){
        // SET CONTEXT
        var context = this.context;
        // context settings
        context.save();
        context.beginPath();
        // move to Y-center : draw X-axis
        context.moveTo(this.centerX, 0);
        context.lineTo(this.centerX, this.canvas.height);
        // set style
        context.strokeStyle = this.axisColor;
        context.lineWidth = 2;
        context.stroke();

        // DRAW TICK MARKS
        var yPosIncrement = this.unitsPerTick * this.unitY;
        var yPos, unit;
        // text settings
        context.font = this.font;
        context.textAlign = 'right';
        context.textBaseline = 'middle';

        // DRAW TOP TICK MARKS
        yPos = this.centerY - yPosIncrement;
        unit = this.unitsPerTick;
        // while Y-position greater than 0
        while(yPos > 0){
            // draw ticks + unit
            context.moveTo(this.centerX - this.tickSize / 2, yPos);
            context.lineTo(this.centerX + this.tickSize / 2, yPos);
            context.stroke();
            context.fillText(unit, this.centerX - this.tickSize / 2 - 3, yPos);
            // change Y-position + unit value
            unit += this.unitsPerTick;
            yPos = Math.round(yPos - yPosIncrement);
        }

        // DRAW BOTTOM TICK MARKS
        yPos = this.centerY + yPosIncrement;
        unit = -1 * this.unitsPerTick;
        // while Y-position smaller than canvas HEIGHT
        while(yPos < this.canvas.height){
            // draw ticks + unit
            context.moveTo(this.centerX - this.tickSize / 2, yPos);
            context.lineTo(this.centerX + this.tickSize / 2, yPos);
            context.stroke();
            context.fillText(unit, this.centerX + this.tickSize / 2 - 3, yPos);
            // change Y-position + unit value
            unit -= this.unitsPerTick;
            yPos = Math.round(yPos + yPosIncrement);
        }
        context.restore();
    };
    /**
     * FUNCTION : DRAW EQUATION
     * @param Yx : Array of points
     * @param color
     * @param thickness
     */
    Graph.prototype.drawEquation = function(Yx, color, thickness) {
        // RETRIEVE CONTEXT
        var context = this.context;
        context.save();
        context.save();
        // translation + scaling
        this.transformContext();

        // CONTEXT SETTINGS : needed for drawing purposes
        context.beginPath();
        context.moveTo(Yx[0][0], Yx[0][1]);

        // DRAW LINE : iteration by iteration
        for(var i = 1; i < Yx.length; i++) {
            context.lineTo(Yx[i][0], Yx[i][1]);
        }

        // LINE SETTINGS
        context.restore();
        context.lineJoin = 'round';
        context.lineWidth = thickness;
        context.strokeStyle = color;
        context.stroke();
        context.restore();
    };

    /**
     * FUNCTION : TRANSFORM CONTEXT - translation + scaling
     */
    Graph.prototype.transformContext = function(){
        //RETRIEVE CONTEXT
        var context = this.context;

        //MOVE CONTEXT TO CENTER OF CANVAS
        this.context.translate(this.centerX, this.centerY);

        // * stretch grid to fit the canvas window, and invert
        // * the y-scale so that it will increment as moving
        // * upwards
        context.scale(this.scaleX, -this.scaleY);
    };

    document.getElementById('equ1').addEventListener('click', function() {
        equationSelected = equation1;
        displayGraph(equationSelected);
    });

    document.getElementById('equ2').addEventListener('click', function() {
        equationSelected = equation2;
        displayGraph(equationSelected);
    });

    document.getElementById('lambda').addEventListener('change', function() {
        displayGraph(equationSelected);
    });

    /**
     * Affichage des graphiques
     */
    function displayGraph(equation) {
        // clear arrays
        Fx = [];
        Gx = [];
        Dx = [];
        racines = [];

        var min;
        var max;
        var lambda = parseInt(document.getElementById('lambda').value)
        if(lambda != 0) {
            calc(equation, lambda);

            if (racines.length == 0) {
                min = -100;
                max = 100;
            } else if (racines.length == 1) {
                min = racines[0] - 10;
                max = racines[0] + 10;
            } else {
                max = Math.round(racines[racines.length - 1]);
                min = Math.round(racines[0]);
            }

            var units = (max <= 20) ? 1 : 10;

            var myGraph = new Graph({
                canvasId: 'myCanvas',
                minX: min,
                minY: min,
                maxX: max,
                maxY: max,
                unitsPerTick: units
            });
            myGraph.drawEquation(Fx, 'red', 1);
            myGraph.drawEquation(Gx, 'blue', 1);
            myGraph.drawEquation(Dx, 'green', 1);

            if (racines.length != 0) {
                document.getElementById('racines').innerHTML = "Racines : ";
                for (var i = 0; i < racines.length; i++) {
                    document.getElementById('racines').innerHTML = document.getElementById('racines').innerHTML + racines[i] + " | ";
                }
            }
        }
        else {
            var myGraph = new Graph({
                canvasId: 'myCanvas',
                minX: -100,
                minY: -100,
                maxX: 100,
                maxY: 100,
                unitsPerTick: 10
            });
        }
    }

    function calc (equation, lambda) {
        var i = 0;
        // the maximum round
        for(var x = -100; x <= 100; x += 0.01) {
            var y = equation(x.toFixed(2));
            if(isFinite(y)){
                Dx.push([x, x]);
                Fx.push([x, y]);
                var g = x + lambda * y;
                Gx.push([x,g]);
                if(Math.round(g*100)/100 == Math.round(x*100)/100){
                    racines.push(Math.round(x*100)/100);
                }
            }
        }
    }

    function equation1(x){
        return Math.sin(x)-x/13;
    }

    function equation2(x) {
        return x/(1-Math.pow(x, 2));
    }


</script>
<!-- JAVASCRIPT END -->
</body>
<!-- BODY END -->
</html>
